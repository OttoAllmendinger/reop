
An (in)formal specification for reop file formats

Base components:
Algorithm - algorithm are specified with two byte indentifiers, usually ASCII
letters related to the algorithm name
Random ID - An opaque key identifier. 8 random bytes.
Identity - A string that identifies the user. Stored outside the base64 data.

General format:
Most files are ASCII, with binary data encoded via base64. File sections are
separated with line separators.

Keys:
Every reop key consists of two curve25519 keys. One is used for encryption.
One is used for signing.

Secret (private) key:
	uint8_t sigalg[2] - Signature key algorithm (Ed)
	uint8_t encalg[2] - Encryption key algorithm (CS)
	uint8_t symalg[2] - Symmetric algorithm. Used to encrypt key itself. (SP)
	uint8_t kdfalg[2] - KDF to derive encryption key (BK)
	uint8_t randomid[8] - 8 bytes used to fast check for mismatches
		[Following fields depend (in theory) on algorithms above]
	uint32_t kfdrounds - big endian
	uint8_t salt[16] - For KDF
	uint8_t nonce[24] - The extra data for key self encryption
	uint8_t tag[16] - Tag to authenticate key self encryption
	uint8_t sigkey[64] - The signature key itself
	uint8_t enckey[32] - The encryption key itself

Secret keys are always encrypted. (No password "unencrypted" keys, specified
by setting kdfrounds to 0, are encrypted with a key of zeros.) Not shown is
the 32 byte key generated by the KDF.

Public key:
        uint8_t sigalg[2];
        uint8_t encalg[2];
        uint8_t randomid[8];
        uint8_t sigkey[32];
        uint8_t enckey[32];

Note that sigkey is only half the size as in the secret key. (The secret
version includes the public key as well).

The sigkey and enckey fields are initialized as per nacl/sodium.
(Implementation defined, not specified here.)

Base64 key encoding:
Keys are preferentially stored in base64 format. The above data is base64
encoded, and then wrapped in REOP guards. An ident line is mandatory and
used to identify the owner of the key; e.g. to match a signature with the
correct public key for verification. There is no space after "ident:".
The remainder of the line is 64 bytes of ASCII or possibly UTF-8 text.
The identifier is not interpreted by reop, but should be human friendly.

-----BEGIN REOP SECRET KEY-----
ident:identifier up to 63 bytes
base64 encoded data, ideally wrapped to 76 char lines
-----END REOP SECRET KEY-----

Public keys are as above, but say PUBLIC KEY.

Key files:
The reop application supports specifying keys on the command line in addition
to reading them from a default ~/.repo location. Most key files consist of a
single key. The exception is a keyring file. Multiple public keys (in base64
format) may be concatenated into one file.

Messages:
There several message types. Encrypted messages and signed messages.
Encrypted messages may further be broken down into asymmetric and symmetric.

Asymmetric Encrypted Messages:
	uint8_t encalg[2]	eC
	uint8_t secrandomid[8]
	uint8_t pubrandomid[8]
	uint8_t ephpubkey[32]
	uint8_t ephnonce[24]
	uint8_t ephtag[16]
	uint8_t nonce[24]
	uint8_t tag[16]

Encrypted messages consist of two sections. A header and the data, both
base64 encoded and wrapped in ASCII guard lines. The ident line identifies
the sender, so that the recipient may select the correct key to authenticate
the message.

An ephemeral key is used to encrypt the message. The ephemeral key is then
itself encrypted with the long term key. This ensures that the sender will
be unable to decrypt the message after sending; only the recipient can open
it now.

Procedure:
	# generate the ephemeral key pair
	ephpub, ephsec = new enc key pair
	# encrypt the message with ephemeral key
	randombytes(encmsg.nonce)
	encdata, encmsg.tag = encrypt(msg, encmsg.nonce, pubkey.enckey, ephsec)
	# encrypt the ephemeral key with long term key
	randombytes(encmsg.ephnonce)
	encmsg.ephpub, encmsg.ephtag = encrypt(ephpub, encmsg.ephnonce,
		pubkey.enckey, seckey.enckey)


-----BEGIN REOP ENCRYPTED MESSAGE-----
ident:sender
base64 header info
-----BEGIN REOP ENCRYPTED MESSAGE DATA-----
base64 message data
-----END REOP ENCRYPTED MESSAGE-----

Symmetric encrypted messages: (password protected)
	uint8_t symalg[2]	SP (Xsalsa20 and Poly1305)
	uint8_t kdfalg[2]	BK (bcrypt)
	uint32_t kdfrounds	network byte order
	uint8_t salt[16]	for KDF
	uint8_t nonce[24]	random nonce for cipher
	uint8_t tag[16]		auth tag to verify decrypt

Symmetric encryption is conceptually simpler. Generate a random salt for
the KDF. Generate a key from the password using the KDF. Encrypt. (Not shown
is the 32 byte key generated by the KDF.)

The ASCII file format is the same as for asymmetric message. The file format
requires an ident line, even though it serves no purpose for these messages.
Instead, a dummy value of "<symmetric>" is used.

-----BEGIN REOP ENCRYPTED MESSAGE-----
ident:<symmetric>
base64 header info
-----BEGIN REOP ENCRYPTED MESSAGE DATA-----
base64 message data
-----END REOP ENCRYPTED MESSAGE-----

Because all encrypted messages, of any type, have a similar structure, it is
first necessay to decode the base64 header in order to inspect the first two
bytes.

Binary messages lack ASCII guard lines, and instead begin with the four byte
signature "RBF\0". This is followed by the header info, as above. Then the
ident length, then the ident. Then the message.

	uint8_t rbfsig[4]	"RBF\0"
	uint8_t symalg[2]	SP or eC (as above)
	more fields		varying as above
	uint32_t identlen	network byte order
	char ident[]		length as per above, no nul
	uint8_t msg[]		the rest of the message, encrypted


